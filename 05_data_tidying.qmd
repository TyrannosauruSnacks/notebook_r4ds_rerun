---
title:       "Data tidying"
author:      "Max Hachemeister"
date:        last-modified
date-format: iso
format:
  gfm:
    toc:     true
---

# Prerequisites

```{r}
#| label: setup
#| results: false
#| warning: false

library(tidyverse)
theme_set(theme_light())
```

# Introduction

## Tidy data

Rules of tidy data:

 1. Each variable is a column; each column is a variable.
 2. Each observation is a row; each row is an observation.
 3. Each value is a cell; each cell is a single value.
  
### Exercises
#### 1. For each of the sample tables, describe what each observation and each column represents.
    
 1. In `table1` each observation represents the population and tuberculosis cases per year per country, while the column represent the variables countries, year, cases and population.
    ```{r}
    table1
    ```
    
 2. In `table2` each observation represents either the number of cases or the population per year per country. Therefore the columns `type` represents two possible variables, namely cases or population.
    ```{r}
    table2
    ```
    
 3. In `table3` each observation represents the calculation of the tuberculosis rate per year per country. The columns `country` and `year` represent their literal variables, whereas `rate`, even though being a variable has two values in its cells.
    ```{r}
    table3
    ```
       
#### 2. Sketch out the process you'd use to calculate the `rate` for `table2` and `table3`.

> You will need to perform four operations:
>
> a. Extract the number of TB cases per country per year.
> b. Extract the matching population per country per year.
> c. Divide cases by population, and multiply by 1000.
> d. Store back in the approriate place.

 1. To calculate the `rate` from `table2` I would have to take the following steps:
    
    - Create separate columns for `cases` and `population`.
    - Move the values accordingly.
    - Mutate a `rate` column with "`cases` / `population`".
  
 2. To do get the `rate` from `table2` the following steps occur to me:
  
    - Mutate a `rate_result` column from the two values in the `rate` column.
      - Like "The number before '/' divided by the number after '/' ".
    - Basically it comes down to separating the two numbers before and after the `/`.
  
## Lengthening data

 - The most common task in tidying original data.
 - Used to convert many columns that are actually the same variable into two columns.
   - One being the common variable in which the old columns are now the values, and the other inheriting the values that were in the original columns.
 - So You are looking at four things in a sense.
 
 - Take note that within `pivot_longer()` the names for the *new* columns have to be quoted, aka. strings, as they do not yet refer to existing objects, like it would be case for `mutate()`.
 
 - Use `parse_number()` to extract the first number after a prefix string like `wk1`, `wk2`, `wk3`, etc. .
 
### How does pivoting work?

Create an example with `tribble()`: 
```{r}
df <- 
  tribble(
    ~id, ~bp1, ~bp2,
    "A", 100,  120,
    "B", 140,  115,
    "C", 120,  125
  )

df
```
 
Now pivot the tibble to have a column for the `number` of the blood pressure measurement and the `value` of that measurement.

```{r}
df |> 
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
```

### Many variables in columns names

 - It is always sensible to describe all the different variables / variables that can be made out from looking at the raw data to get a feeling for how many columns there are and which name they might get.
 - In the `who2` example there are six columns / variables, including that describing the values that are given in the original columns.
 - Try to visualize how each original rows get repeatet by the number of original columns to be pivoted.
   - Simply because, and that's not so intuitive, no new data is created, but the data as is just rearranged.
   
### Data an variable names in the column headers

 - Okay, this is a complex case:
```{r}
household
```

 - The original columns describe several values of a single variable (`child`), and at the same time two other distinc variables (`name`, and `dob`).
 
 - `pivot_longer()` has special solution for that with the `.value` *sentinel* as a value for the `names_to` argument.
 
   - This way, each unique value of the position in the string you described with `.value` will become a new column which will be populated with the original values. Check it out:

```{r}
household |> 
  pivot_longer(
    # All columns, but `family`
    cols = !family,
    # Take the first value in the column string and separate unique names
    names_to = c(".value", "child"),
    # The column strings are separeted by "_"
    names_sep = "_",
    # Ignore rows that would have NA as value.
    values_drop_na = TRUE
  )
```

 - So now we see that the actual observation is not the family, but the single child.