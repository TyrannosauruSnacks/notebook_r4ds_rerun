---
title: "03 Data transformation"
author: "Max Hachemeister"
format:
  gfm:
    toc: true
editor: source
---

## Prerequisites

```{r}

#| label: setup
#| output: false

library(tidyverse)
library(nycflights13)
set_theme(theme_light())

```
	
## Link to website

- <https://r4ds.hadley.nz/data-transform.html>

## Introduction

Take a look at the `flights` dataframe, by either `glimpse()` or just typing the object directly. I will use the former:

```{r}
glimpse(flights)
```

## Rows

`filter()` changes which rows are present without changing their order.

`arrange()` changes the order of the rows without changing which are present.

`distinct()` finds rows with unique values.

### `filter()`

Find all flights with that departed more than 120 minutes late:

```{r}
flights |> 
  filter(dep_delay > 120)
```

 | 
---   | ---
`>`   | greater than
`>=`  | greater than or equal 
`<`   | less than
`<=`  | less than or equal to
`==`  | equal to (notice the two "**=**" )
`!=`  | not equal to

Also several conditions can be combined:

  |   
--- | ---
`&` | AND
`\|` | OR

E.g. find all flights that departed in January OR February (which can be translated to [...] all departures of January and February):

```{r}
flights |> 
  filter(month == 1 | month == 2)
```

Ah you couldn't even navigate to the ones from February, because there are `{r} nrow(flights |> filter(month == 1 | month == 2))` rows in total, even after the filtering.

Let's find all flights that departed on the 1st of January:

```{r}
flights |> 
  filter(month == 1 & day == 1)
```


Oh and there is this `%in%`, which followed by a vector (`c(value1, value2)`) can be used to spare you typing a lot of `==`, `|` combinations. E.g. for finding all the flights that departed in January, or February, or March you could just write:

```{r}
flights |> 
  filter(month %in% c(1, 2, 3))
```

While the long version would be:

```{r}
flights |> 
  filter(month == 1 | month == 2 | month == 3)
```

Important to know is that `filter()` never changes the input.
That means to save the results you need to assign them to an object:

```{r}
#| output: false

jan1 <- 
  flights |> 
  filter(month == 1 & day == 2)

jan1
```


### `arrange()`

`arrange()` changes the order of the rows, by the columns you provide as argument. Every additional column will break ties of the preceding ones, which translates to: "Arrange by attribute1 and then arrange all those with the same attribute1-values by the values of attribute2".

For example: "Arrange all flights by Year, and all of the same year then by month, and then within each month by day and within each day by departure time.", would translate to code as:

```{r}
flights |> 
  arrange(
    year,
    month,
    day,
    dep_time
  )
```

And If I wanted to arrange any of the columns from highest to lowest, I can put it in the `desc()` function:

```{r}
flights |> 
  arrange(
    year,
    desc(month),
    desc(day),
    dep_time
  )

```

### `distinct()`

So `distinct()` foremost filters out duplicate rows in a dataset, so we could see, whether there are duplicates in the `flights` dataset:
```{r}
# from the flights dataframe filter out duplicate rows and then count the remaining
flights |> 
  distinct() |> 
  nrow()

# from the flights dataframe count all the rows
flights |> 
  nrow()
```

`distinct()` further finds all the unique combinations for provided columns:
```{r}
# from the flights dataframe find all unique tailnumber and destination pairs
flights |> 
  distinct(tailnum, dest)

# lets see whether the order makes a difference
flights |> 
  distinct(dest, tailnum)
```

So the order of the argument just changes the form of the output. If I want to keep all the columns in the output, I can use the `.keep_all = TRUE` option:

```{r}
flights |> 
  distinct(tailnum, dest,
           .keep_all = TRUE)
```

`distinct()` always gives you the first instance of a distinct row it finds. As somewhat of an extension to this `count()` also give you the distinct combinations of the defined columns, but also the number times each combination occurs. More on that in another section though.

```{r}
flights |> 
  count(tailnum, dest, sort = TRUE)
```
### Exercises

#### 1.

> In a single pipeline for each condition, find all flights that meet the condition:
>
> * Had an arrival delay of two or more hours
> * Flew to Houston (`IAH` or `HOU`)
> * Were operated by United, American, or Delta
> * Departed in summer (July, August, and September)
> * Arrived more than two hours late but didn't leave late
> * Were delayed by at least an hour, but made up over 30 minutes in flight

```{r}
# Had an arrival delay of two or more hours
flights |> 
  filter(arr_delay >= 120)

# Flew to Houston (`IAH` or `HOU`)
flights |> 
  filter(dest == "IAH" | dest == "HOU")

## or the elegant version
flights |> 
  filter(dest %in% c("IAH", "HOU"))

# Were operated by United, American, or Delta
## Check the abbreviation for the `airlines`
airlines

## So we have UA, AA, and DL
flights |> 
  filter(carrier %in% c("UA", "AA", "DL"))

# Departed in summer (July, August, and September)
flights |> 
  filter(month %in% c(6, 7, 8))

## Or slightly more elegant
flights |> 
  filter(month %in% 6:8)

# Arrived more than two hours late but didn't leave late
flights |> 
  filter(arr_delay >= 120 & dep_delay <= 0)

# Were delayed by at least an hour, but made up over 30 minutes
flights |> 
  filter(dep_delay >= 60 & arr_delay < dep_delay - 30)

## Just checking whether I can write it differently
flights |> 
  filter(dep_delay >= 60 & dep_delay - arr_delay >= 30)

### It seems to get different results. Let's compare the solutions: 
flights |> 
  select(dep_delay, arr_delay) |>
  mutate(time_won = dep_delay - arr_delay,
         won_30 = arr_delay < dep_delay - 30,
         won_30_alt = time_won >= 30) |> 
  filter(won_30 != won_30_alt)

### Ah yeah, actually they both give the same result, when I keep the `=` for both comparisons
### Hat another intuition when writing the first call
### Correct version
flights |> 
  select(dep_delay, arr_delay) |>
  mutate(time_won = dep_delay - arr_delay,
         won_30 = arr_delay <= dep_delay - 30,
         won_30_alt = time_won >= 30) |> 
  filter(won_30 != won_30_alt)

```

#### 2.

> Sort `flights` to find the flights with the longest departure delays. Find the flights that left earliest in the morning.

```{r}
# Flights with the longest delay
flights |> 
  arrange(desc(dep_delay))

# Flights that left earliest in the morning
flights |> 
  arrange(dep_time)
```

#### 3.

> Sort `flights` to find the fastest flights. (Hint: Try including a math calculation inside of your function)

```{r}
#| error: true

flights |> 
  arrange(air_time)

# Ahh okay with fastest, I guess It should be the most `distance` per `air_time`
# This would translate to miles per minute
flights |> 
  arrange(desc(distance / air_time)) |> 
  select(distance, air_time)

## Yeah let's actually add this as a column to see what's happening
flights |>
  mutate(miles_minutes = distance / air_time) |> 
  arrange(desc(miles_minutes)) |> 
  select(distance, air_time, miles_minutes)

## Can I do this directly in `arrange()`
flights |> 
  arrange(miles_minutes = distance / air_time) |> 
  select(distance, air_time, miles_minutes)
#### No :-)

## But I can make it miles per hour at least
flights |> 
  mutate(miles_hour = distance / (air_time / 60)) |> 
  arrange(desc(miles_hour)) |> 
  select(distance, air_time, miles_hour)
```

#### 4.

> Was there a flight on every day of 2013?

```{r}
flights |> 
  distinct(day)

# A yeah this way I only get the distinct days.
# But they can repeat for each month

flights |> 
  distinct(month, day)

# To make it precise, let's count the rows
flights |> 
  distinct(month, day) |> 
  nrow()
```

#### 5.

> Which flights traveled the farthest distance? Which traveled the least distance?

```{r}
# Farthest distance
flights |> 
  arrange(desc(distance)) |> 
  select(flight, distance)

# Least distance
flights |> 
  arrange(distance) |> 
  select(flight, distance)
```

#### 6.

> Does it matter what order you used `filter()` and `arrange()` if you're using both? Why/Why not? Think about the results and how much work the functions would have to do.

`arrange()` will always compare all rows, so If I would `filter()` before that, fewer rows will have to be compared by `arrange()`.

For example `flights` has `{r} nrow(flights)` rows, while after filtering for the `AA` `carrier` there will be only `{r} nrow(flights |> filter(carrier == "AA"))` to `arrange()`.

```{r}
flights |> 
  filter(carrier == "AA") |> 
  arrange(desc(arr_delay)) |> 
  select(arr_delay)
```

## Columns

### `mutate()`

- Adds new columns that are calculated with values from existing ones.

For example, we could compute the `speed` and how much time each flight made up, i. e. `gain`ed:
```{r}
#| label: gain and speed

flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  )
```

This is hard to see because by default the new columns are added to the 'right' of the dataframe. `.before` as an argument changes this to the 'left':
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )
```
Note that `.before` is written with the `.` to identify it as an argument of the function instead of a new column to be created. Also note how it takes either numbers as the position, or the actual name of a row as a variable.
You can also use `.after` in an analog manner.
Ahh, and there is `.keep`, for which you can set `"used"` to keep only the newly created columns and those relevant to these calculations. Also the other values for `.keep` are helpful for tidy output.
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```
### `select()`

- Reduces the data to columns of interest

-   Select columns by name:

    ```{r}
    #| results: false
    flights |>
      select(year, month, day)
    ```

-   Select all columns between year and day:

    ```{r}
    #| results: false
    flights |>
      select(year:day)
    ```
    
-   Select all columns exept those from year to day:
    
    ```{r}
    #| results: false
    flights |>
      select(!year:day)
    ```

Ah interesting, back in the day you could also have done this 'negative' selection with `-`, but it has been changed to `!` for consistency with other `select()` features.

-   Select all columns that are characters:

    ```{r}
    #| results: false
    flights |>
      select(where(is.character))
    ```

There are more ways to select columns by "regular" expressions and some other functions:

- `starts_with()`
- `ends_with()`
- `contains()`
- `num_range()`

But more on that in a later section.

### `rename()`

  - renames columns by `newname = oldname` syntax:

    ```{r}
    #| results: false
    flights |>
      rename(tail_num = tailnum)
    ```

### `relocate()`

  - moves columns, i. e. changes their order
  
    ```{r}
    #| results: false
    flights |>
      relocate(time_hour, air_time)
    ```
  - Can I also rename in the same step?
  
    ```{r}
    flights |>
      relocate(time = time_hour,
               duration = air_time)
    ```
    - Yes, nice!

### Exercises

#### 1.

> Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?

Take a look at those columns only:
```{r}
flights |>
  select(dep_time, sched_dep_time, dep_delay)
```

Seems like `dep_delay` is just calculated from `dep_time` and `sched_dep_time`. Let's check that by creating a column with this calculation:
```{r}
flights |>
  mutate(delay_check = dep_time - sched_dep_time)
```

Well I can't see them that well. Let's also `select()` those of interest:
```{r}
flights |>
  mutate(delay_check = dep_time - sched_dep_time) |>
  select(dep_time, sched_dep_time, delay_check, dep_delay)
```
Aha interesting, so it's not simple subtraction because these numbers represent hours and minutes, therefore the difference in minutes between 554 and 600 would be -6 instead of -46.  
Okay, but let's not get caught up here an move on to the next question.

#### 2. 

> Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.

  - Describe them directly:
    
    ```{r}
    #| results: false
    flights |> 
      select(dep_time, dep_delay, arr_time, arr_delay)
    ```

  - Use numbers instead:
    
    ```{r}
    #| results: false
    flights |>
      select(4, 6, 7, 9)
    ```

  - Not select everything else:
  
    ```{r}
    flights |>
      select(!year:day, !sched_dep_time, 
             !sched_arr_time, !carrier:time_hour)
    ```
      - Okay this NOT works only for one value, but all after that seem to be ignored.
  - I checked the documentation and it seems like I should put all those into a vector like so:
      
    ```{r}
    flights |>
      select(!c(year:day, sched_dep_time, 
             sched_arr_time, carrier:time_hour))
    ```

  - Let's try these helper functions:
    ```{r}
    flights |>
      select(starts_with("arr_"), starts_with("dep_"))
    ```
    - This worked, nice!
    
    ```{r}
	
    flights |>
      select(contains("time"), contains("delay"))
    
    ```
    - Yeah not exactly, but okay.

  - I think I could pipe this aswell

	```{r}

    flights |>
      select(ends_with("_time"), ends_with("_delay")) |>
      select(!contains(c("sched", "air")))
    
	```
	- A well, I guess this could go on for quite a while. I liked the `starts_with()` version the most.

#### 4.

> What does the `any_of()` function do? Why might it be helpful in conjunction with this vector?
>
> ```{r}
>
> variables <- c("year", "month", "day", "dep_delay", "arr_delay")
>
> ```

So `any_of()` is a selection helper for the `select()` or `relocate()` functions, especially deselecting unwanted columns. There is also `all_of()`, which is more for direct selection, as it gives an error, if target columns are missing. 

So this here would be the intended use:

```{r}

flights |>
  select(!any_of(variables))

```

Which gives me a tibble without any of the `variables`.

#### 5. 

> Does the result of running the following code surprise you? How do the select helpers deal with upper and lower case by default? How can you change that default?
>  
> ```{r}
> #| results: false
> flights |> select(contains("TIME"))
> ```

So `contains()` ignores case. How could I change this?
The documentation says there is a `ignore.case` option.

```{r}
flights |> select(contains("TIME", ignore.case = FALSE))
```

#### 6.

> Rename `air_time` to `air_time_min` to indicate units of measurement and move it to the beginning of the data frame.

```{r}
flights |> 
  rename(air_time_min = air_time)
```
Ah, I can't see the row. Let's do it directly within the `select()` function:

```{r}
flights |> 
  select(air_time_min = air_time)
```

#### 6.

> Why doesn't the following work, and what does the error mean?
>
> ```{r}
> #| error: true
> flights |> 
>   select(tailnum) |> 
>   arrange(arr_delay)
> ```

This does not work, because after `select(tailnum)` there is no `arr_delay` column, and therefore `arrange()` gives an error. If I wanted to make this work I should arrange first:
```{r}
flights |> 
  arrange(arr_delay) |> 
  select(tailnum)
```

But I think it's more sensible to leave `arr_delay` in if i arrange by that:
```{r}
flights |> 
  select(tailnum, arr_delay) |> 
  arrange(arr_delay)
```

## The pipe

The pipe `|>` is now native to R and can be used interchangeably with the `%>%` margrittr pipe operator, where the former is recommended.

## Groups

### `group_by()`

  - Divides the dataset into meaningful subgroups.
  - Does not change the data as is.
  
```{r}
flights |> 
  group_by(month)
```


### `summarize()`

  - Does group wise calculations.
  - Used in conjunction with `group_by()`.
  
```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay)
  )
```

  - `mean()` gives `NA` if there are missing values, use `na.rm = TRUE` to ignore those for the calculation.
  
```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE)
  )
```
  - `n()` can become an instinctive part of calling `summarize()`, at least when it comes to data exploration
```{r}
flights |> 
  group_by(month) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  )
```
### The `slice_` functions

  - A group of functions to get specific rows of a dataset.
  - Works well with `group_by()`.
  - Use argument `prop =` to get results in proportion to number of observations for each group

Get the most delayed flight for each destination:
```{r}
flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1) |> 
  relocate(dest, arr_delay)
```
  - Ties are kept by default, so there might be more rows than groups.
  
### Grouping by multiple variables

  - Multiple variables are subgrouped in the given order.
  - `summarize()` drops one grouping layer by default.
    - You will get a message though, and for later code should define the behaviour you want.
  
```{r}
daily <- flights |> 
  group_by(year, month, day)
daily

daily_flights <- daily |> 
  summarize(n = n())
daily_flights

daily_flights <- daily |> 
  summarize(n = n(),
            .groups = "drop")
daily_flights
```

### Ungrouping

  - Use `ungroup()` to remove grouping outside of `summarize()`

### `.by`

  - Alternative to `group_by()`.
  - Is a special argument within `summarize()` and other functions.
    - Several groups then need to be in a vector `c()` though.
  
```{r}
flights |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE),
    n = n(),
    .by = c(origin, dest)
  )
```

### Exercises

#### 1.

> Which carrier has the worst average delays? Challenge: can you disentangle the effect of bad airports vs. bad carriers? Why/Why not? (Hint: think about `flights |> group_by(carrier, dest) |> summarize(n())`)

Find the the carrier with the worst *average* delays:

```{r}
flights |> 
  # Get the average delay per carrier
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = carrier) |> 
  # Slice the row with the most delay
  slice_max(n = 1, avg_delay)
```
Carrier `F9` has the most delay.

Disentangle bad carriers from bad airports:

```{r}
flights |> 
  # Get average delay per carrier and destination
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = c(carrier, dest))
```
I think I would need to compare the average delay per destination with the average delay per carrier of that destination to see whether the destinations are always late, or the carriers.

```{r}
flights |> 
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = c(dest, carrier)) |> 
  # Get the destination and carrier combo with the worst delay
  slice_max(avg_delay, n = 10)
```
Now we see that for this combination there are only two records, so this might just have been bad luck. I want to check how "STL" and "UA" do on their own overall.
```{r}
# Get the 10 most delayed destinations
flights |> 
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = dest) |> 
  slice_max(avg_delay, n = 10)

# Get the 10 most delayed carriers
flights |> 
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = carrier) |> 
  slice_max(avg_delay, n = 10)
```

Now we know that UA is one of the most delayed carriers, while the destination STL is not in its top 10. I think the catch is, that if there is a big airline frequenting an airport more often than other airlines It could be responsible for a lot of delay on that airport, even though that airport would otherwise do fine. And also the other way around. So there would have to be some proportionality of that delay. Man that's to high up for my brain.

What I could do is at least check, how often either an airport, or an carrier is in the  of a given group. Let's see:
```{r}
flights |> 
  # Get average delay per of all the carriers for all the destinations
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = c(dest, carrier)) |> 
  # Get the entries with the most average delay for each destination
  slice_max(avg_delay, by = dest, n = 1) |> 
  # Get for how many destinations each carrier is the most delayed
  count(carrier, sort = TRUE)
```
We see that EV has the most average delay for the largest number of destinations.

Let's do it also for destinations:
```{r}
flights |> 
  # Get average delay for all the destinations of each carrier
  summarize(avg_delay = mean(dep_delay, na.rm = TRUE),
            n = n(),
            .by = c(carrier, dest)) |> 
  # Get the entries with the most average delay for each destination
  slice_max(avg_delay, by = carrier, n = 1) |> 
  # Get for how many carriers each destination is the most delayed
  count(dest, sort = TRUE)
```

Ah, because there only a few airlines this exploration is not as useful, because there are to few observations to actually see a difference. We could go into the top ten and see what that does for us:

```{r}
flights |>
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n(),
    .by = c(carrier, dest)
  ) |>
  slice_max(avg_delay, by = carrier, n = 10) |>
  count(dest, sort = TRUE)
```
Lastly we can check whether EV and ORD are actually causing each others delay because they do a lot of flights together:
```{r}
# How often is ORD a destination of a certain carrier
flights |> 
  filter(dest == "ORD") |> 
  summarize(n = n(),
            .by = carrier)


# How many flights of EV are there in general
flights |> 
  filter(carrier == "EV") |> 
  count()
```

So let's summarize. I think that the carrier with the most delay is probably EV, whereas the destination with the most delay is probably ORD, but for that the latter the data as I presented it more sparse. But EV is generally late despite only having had two flights to ORD as opposed to the other 54,171 to other airports.
Last