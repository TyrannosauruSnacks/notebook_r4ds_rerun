---
title: "03 Data transformation"
author: "Max Hachemeister"
format:
  gfm:
    toc: true
editor: source
---

## Prerequisites

```{r}
#| label: setup
#| output: false

library(tidyverse)
library(nycflights13)
set_theme(theme_light())

```
	
## Link to website

- <https://r4ds.hadley.nz/data-transform.html>

## Introduction

Take a look at the `flights` dataframe, by either `glimpse()` or just typing the object directly. I will use the former:

```{r}
glimpse(flights)
```

## Rows

`filter()` changes which rows are present without changing their order.

`arrange()` changes the order of the rows without changing which are present.

`distinct()` finds rows with unique values.

### `filter()`

Find all flights with that departed more than 120 minutes late:

```{r}
flights |> 
  filter(dep_delay > 120)
```

 | 
---   | ---
`>`   | greater than
`>=`  | greater than or equal 
`<`   | less than
`<=`  | less than or equal to
`==`  | equal to (notice the two "**=**" )
`!=`  | not equal to

Also several conditions can be combined:

  |   
--- | ---
`&` | AND
`\|` | OR

E.g. find all flights that departed in January OR February (which can be translated to [...] all departures of January and February):

```{r}
flights |> 
  filter(month == 1 | month == 2)
```

Ah you couldn't even navigate to the ones from February, because there are `{r} nrow(flights |> filter(month == 1 | month == 2))` rows in total, even after the filtering.

Let's find all flights that departed on the 1st of January:

```{r}
flights |> 
  filter(month == 1 & day == 1)
```


Oh and there is this `%in%`, which followed by a vector (`c(value1, value2)`) can be used to spare you typing a lot of `==`, `|` combinations. E.g. for finding all the flights that departed in January, or February, or March you could just write:

```{r}
flights |> 
  filter(month %in% c(1, 2, 3))
```

While the long version would be:

```{r}
flights |> 
  filter(month == 1 | month == 2 | month == 3)
```

Important to know is that `filter()` never changes the input.
That means to save the results you need to assign them to an object:

```{r}
#| output: false

jan1 <- 
  flights |> 
  filter(month == 1 & day == 2)

jan1
```


### `arrange()`

`arrange()` changes the order of the rows, by the columns you provide as argument. Every additional column will break ties of the preceding ones, which translates to: "Arrange by attribute1 and then arrange all those with the same attribute1-values by the values of attribute2".

For example: "Arrange all flights by Year, and all of the same year then by month, and then within each month by day and within each day by departure time.", would translate to code as:

```{r}
flights |> 
  arrange(
    year,
    month,
    day,
    dep_time
  )
```

And If I wanted to arrange any of the columns from highest to lowest, I can put it in the `desc()` function:

```{r}
flights |> 
  arrange(
    year,
    desc(month),
    desc(day),
    dep_time
  )

```

### `distinct()`

So `distinct()` foremost filters out duplicate rows in a dataset, so we could see, whether there are duplicates in the `flights` dataset:
```{r}
# from the flights dataframe filter out duplicate rows and then count the remaining
flights |> 
  distinct() |> 
  nrow()

# from the flights dataframe count all the rows
flights |> 
  nrow()
```

`distinct()` further finds all the unique combinations for provided columns:
```{r}
# from the flights dataframe find all unique tailnumber and destination pairs
flights |> 
  distinct(tailnum, dest)

# lets see whether the order makes a difference
flights |> 
  distinct(dest, tailnum)
```

So the order of the argument just changes the form of the output. If I want to keep all the columns in the output, I can use the `.keep_all = TRUE` option:

```{r}
flights |> 
  distinct(tailnum, dest,
           .keep_all = TRUE)
```

`distinct()` always gives you the first instance of a distinct row it finds. As somewhat of an extension to this `count()` also give you the distinct combinations of the defined columns, but also the number times each combination occurs. More on that in another section though.

```{r}
flights |> 
  count(tailnum, dest, sort = TRUE)
```
### Exercises

#### 1.

> In a single pipeline for each condition, find all flights that meet the condition:
>
> * Had an arrival delay of two or more hours
> * Flew to Houston (`IAH` or `HOU`)
> * Were operated by United, American, or Delta
> * Departed in summer (July, August, and September)
> * Arrived more than two hours late but didn't leave late
> * Were delayed by at least an hour, but made up over 30 minutes in flight

```{r}
# Had an arrival delay of two or more hours
flights |> 
  filter(arr_delay >= 120)

# Flew to Houston (`IAH` or `HOU`)
flights |> 
  filter(dest == "IAH" | dest == "HOU")

## or the elegant version
flights |> 
  filter(dest %in% c("IAH", "HOU"))

# Were operated by United, American, or Delta
## Check the abbreviation for the `airlines`
airlines

## So we have UA, AA, and DL
flights |> 
  filter(carrier %in% c("UA", "AA", "DL"))

# Departed in summer (July, August, and September)
flights |> 
  filter(month %in% c(6, 7, 8))

## Or slightly more elegant
flights |> 
  filter(month %in% 6:8)

# Arrived more than two hours late but didn't leave late
flights |> 
  filter(arr_delay >= 120 & dep_delay <= 0)

# Were delayed by at least an hour, but made up over 30 minutes
flights |> 
  filter(dep_delay >= 60 & arr_delay < dep_delay - 30)

## Just checking whether I can write it differently
flights |> 
  filter(dep_delay >= 60 & dep_delay - arr_delay >= 30)

### It seems to get different results. Let's compare the solutions: 
flights |> 
  select(dep_delay, arr_delay) |>
  mutate(time_won = dep_delay - arr_delay,
         won_30 = arr_delay < dep_delay - 30,
         won_30_alt = time_won >= 30) |> 
  filter(won_30 != won_30_alt)

### Ah yeah, actually they both give the same result, when I keep the `=` for both comparisons
### Hat another intuition when writing the first call
### Correct version
flights |> 
  select(dep_delay, arr_delay) |>
  mutate(time_won = dep_delay - arr_delay,
         won_30 = arr_delay <= dep_delay - 30,
         won_30_alt = time_won >= 30) |> 
  filter(won_30 != won_30_alt)

```

#### 2.

> Sort `flights` to find the flights with the longest departure delays. Find the flights that left earliest in the morning.

```{r}
# Flights with the longest delay
flights |> 
  arrange(desc(dep_delay))

# Flights that left earliest in the morning
flights |> 
  arrange(dep_time)
```

#### 3.

> Sort `flights` to find the fastest flights. (Hint: Try including a math calculation inside of your function)

```{r}
#| error: true

flights |> 
  arrange(air_time)

# Ahh okay with fastest, I guess It should be the most `distance` per `air_time`
# This would translate to miles per minute
flights |> 
  arrange(desc(distance / air_time)) |> 
  select(distance, air_time)

## Yeah let's actually add this as a column to see what's happening
flights |>
  mutate(miles_minutes = distance / air_time) |> 
  arrange(desc(miles_minutes)) |> 
  select(distance, air_time, miles_minutes)

## Can I do this directly in `arrange()`
flights |> 
  arrange(miles_minutes = distance / air_time) |> 
  select(distance, air_time, miles_minutes)
#### No :-)

## But I can make it miles per hour at least
flights |> 
  mutate(miles_hour = distance / (air_time / 60)) |> 
  arrange(desc(miles_hour)) |> 
  select(distance, air_time, miles_hour)
```

#### 4.

> Was there a flight on every day of 2013?

```{r}
flights |> 
  distinct(day)

# A yeah this way I only get the distinct days.
# But they can repeat for each month

flights |> 
  distinct(month, day)

# To make it precise, let's count the rows
flights |> 
  distinct(month, day) |> 
  nrow()
```

#### 5.

> Which flights traveled the farthest distance? Which traveled the least distance?

```{r}
# Farthest distance
flights |> 
  arrange(desc(distance)) |> 
  select(flight, distance)

# Least distance
flights |> 
  arrange(distance) |> 
  select(flight, distance)
```

#### 6.

> Does it matter what order you used `filter()` and `arrange()` if you're using both? Why/Why not? Think about the results and how much work the functions would have to do.

`arrange()` will always compare all rows, so If I would `filter()` before that, fewer rows will have to be compared by `arrange()`.

For example `flights` has `{r} nrow(flights)` rows, while after filtering for the `AA` `carrier` there will be only `{r} nrow(flights |> filter(carrier == "AA"))` to `arrange()`.

```{r}
flights |> 
  filter(carrier == "AA") |> 
  arrange(desc(arr_delay)) |> 
  select(arr_delay)
```

## Columns

### `mutate()`

- Adds new columns that are calculated with values from existing ones.

For example, we could compute the `speed` and how much time each flight made up, i. e. `gain`ed:
```{r}
#| label: gain and speed

flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  )
```

This is hard to see because by default the new columns are added to the 'right' of the dataframe. `.before` as an argument changes this to the 'left':
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )
```
Note that `.before` is written with the `.` to identify it as an argument of the function instead of a new column to be created. Also note how it takes either numbers as the position, or the actual name of a row as a variable.
You can also use `.after` in an analog manner.
Ahh, and there is `.keep`, for which you can set `"used"` to keep only the newly created columns and those relevant to these calculations. Also the other values for `.keep` are helpful for tidy output.
```{r}
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```
### `select()`

- Reduces the data to columns of interest

-   Select columns by name:

    ```{r}
    #| results: false
    flights |>
      select(year, month, day)
    ```

-   Select all columns between year and day:

    ```{r}
    #| results: false
    flights |>
      select(year:day)
    ```
    
-   Select all columns exept those from year to day:
    
    ```{r}
    #| results: false
    flights |>
      select(!year:day)
    ```

Ah interesting, back in the day you could also have done this 'negative' selection with `-`, but it has been changed to `!` for consistency with other `select()` features.

-   Select all columns that are characters:

    ```{r}
    #| results: false
    flights |>
      select(where(is.character))
    ```

There are more ways to select columns by "regular" expressions and some other functions:

- `starts_with()`
- `ends_with()`
- `contains()`
- `num_range()`

But more on that in a later section.

### `rename()`

  - renames columns by `newname = oldname` syntax:

    ```{r}
    #| results: false
    flights |>
      rename(tail_num = tailnum)
    ```

### `relocate()`

  - moves columns, i. e. changes their order
  
    ```{r}
    #| results: false
    flights |>
      relocate(time_hour, air_time)
    ```
  - Can I also rename in the same step?
  
    ```{r}
    flights |>
      relocate(time = time_hour,
               duration = air_time)
    ```
    - Yes, nice!

### Exercises

#### 1.

> Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?

Take a look at those columns only:
```{r}
flights |>
  select(dep_time, sched_dep_time, dep_delay)
```

Seems like `dep_delay` is just calculated from `dep_time` and `sched_dep_time`. Let's check that by creating a column with this calculation:
```{r}
flights |>
  mutate(delay_check = dep_time - sched_dep_time)
```

Well I can't see them that well. Let's also `select()` those of interest:
```{r}
flights |>
  mutate(delay_check = dep_time - sched_dep_time) |>
  select(dep_time, sched_dep_time, delay_check, dep_delay)
```
Aha interesting, so it's not simple subtraction because these numbers represent hours and minutes, therefore the difference in minutes between 554 and 600 would be -6 instead of -46.  
Okay, but let's not get caught up here an move on to the next question.

2. 

> Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.

  - Describe them directly:
    
    ```{r}
    #| results: false
    flights |> 
      select(dep_time, dep_delay, arr_time, arr_delay)
    ```

  - Use numbers instead:
    
    ```{r}
    #| results: false
    flights |>
      select(4, 6, 7, 9)
    ```

  - Not select everything else:
  
    ```{r}
    flights |>
      select(!year:day, !sched_dep_time, 
             !sched_arr_time, !carrier:time_hour)
    ```
      - Okay this NOT works only for one value, but all after that seem to be ignored.
  - I checked the documentation and it seems like I should put all those into a vector like so:
      
    ```{r}
    flights |>
      select(!c(year:day, sched_dep_time, 
             sched_arr_time, carrier:time_hour))
    ```

  - Let's try these helper functions:
    ```{r}
    flights |>
      select(starts_with("arr_"), starts_with("dep_"))
    ```
    - This worked, nice!
    
    ```{r}
    flights |>
      select(contains("time"), contains("delay"))
    ```
    - Yeah not exactly, but okay.
    
    
